set nocompatible

" Create the 'vimrc' autocmd group, used below, and immediately clear it in
" case this file is being sourced a second time.
augroup vimrc | execute 'autocmd!' | augroup END

" Use <space> as <leader> instead of '\'
let mapleader = ' '

"== General ==================================================================

" Encoding vim uses to render text
set encoding=utf-8
" Set the terminal title
set title
" Change the bell from beep to flash
" (can also use: set noerrorbells, or remove all system bells in .bashrc)
set visualbell
" Don't wait too long to process terminal escape sequences such as the arrow
" keys and the F keys, since they commonly use 'O' in the escape sequence,
" which results in the 'O' command being excessively slow, as vim sometimes
" waits for the timeout. The 'O' slowness is sporadic, so the root cause is
" just an educated guess.
set ttimeoutlen=10
" Display incomplete commands
set showcmd
" Show cursor line/char position
set ruler
" Shorten feedback messages. :help shortmess
set shortmess=atI
" Number lines relative to the cursor
set number
" Show matching brackets / parentheses
set showmatch
" Don't wrap lines
set nowrap
" Don't move cursor to the start of the line on gg, G, and various friends
set nostartofline
" Smart tab completion for vim commands
set wildmenu wildmode=list:longest,full
" Case-insensitive file name completion
if version >= 703
    set wildignorecase
endif
" Keep a longer history (default is 20)
set history=10000
" Don't separate joined sentences by two spaces
set nojoinspaces
" Default clipboard to "+
" This is glitchy on OS X unless 'unnamed' is also included
set clipboard=unnamedplus,unnamed,exclude:cons\|linux
" Intuitive backspacing in insert mode
set backspace=indent,eol,start

" Allow settings to be tweaked via comments within the source file. Override
" distro default for number of lines checked for modelines. On OS X, for
" instance, this defaults to 0.
set modeline modelines=5
" Disable modelines when editing git commit messages, to allow commit subjects
" like 'vim: ...'
autocmd vimrc FileType gitcommit,gitrebase setlocal nomodeline

" Jump back in the jump list via shift-tab
nnoremap <s-tab> <c-o>

" Treat c_^x as i_^x (keyword completion)
cnoremap <c-x> <c-f>i<c-x>

" Save current buffer
nmap <silent> <leader><leader> :update<cr><c-l>

" Pathogen: https://github.com/tpope/vim-pathogen
silent! execute pathogen#infect()

"== Temp files ===============================================================

" Make a backup before overwriting a file
set backup
" Persist undo history across sessions
set undofile

" Temp files
if has("win32")
  " Directory for swap files
  set directory=$TEMP,$TMP,.
  " Don't overwrite symlinks in Windows
  set backupcopy=yes
else
  set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
endif
" Directory for backups, which happen before every write
let &backupdir=&directory
" Directory for undo files, used for undo persistence
let &undodir=&directory

" Credit: tpope
" Delete swapfiles for unmodified buffers
autocmd vimrc CursorHold,BufWritePost,BufReadPost,BufLeave *
      \ if !$VIMSWAP && isdirectory(expand("<amatch>:h")) |
      \   let &swapfile = &modified |
      \ endif

"== Search ===================================================================

" Search incrementally, and case insensitively unless pattern has upper-case
" characters
set incsearch ignorecase smartcase
" Highlight all search term matches
set hlsearch
" Don't auto-highlight the last search (relevant when $MYVIMRC is sourced)
nohlsearch
" Toggle search term highlighting
nnoremap <silent> <leader>h :set hlsearch!<cr>

function! RedrawExtra()
  diffupdate
  if exists('b:sy') && b:sy.active
    call sy#start()
  endif
endfunction

" When forcing a screen redraw:
"   - Stop highlighting current search term
"   - Update the diff
"   - Reset signs for vim-signify
nnoremap <silent> <c-l> :<c-u>nohlsearch \| call RedrawExtra()<cr><c-l>

function! GetVisualSelection()
  let orig_a = ['a', getreg('a'), getregtype('a')]
  normal! gv"ay
  let selection = [@a, getregtype('a')]
  call call('setreg', orig_a)
  return selection
endfunction

function! GetVisualSelectionAsRegex()
  let [value, regtype] = GetVisualSelection()
  let [p_start, p_linesep, p_end] =
        \ regtype =~ '\d\+' ? ['\V', '\.\*\n\.\*', ''] :
        \ regtype ==# 'V'   ? ['\V\^', '\n', '\$'] :
        \                     ['\V', '\n', '']
  return p_start.join(split(escape(value, '\'), "\n"), p_linesep).p_end
endfunction

function! DoSearch(expr, flags)
  let @/ = a:expr
  call histadd("/", @/)
  execute 'normal! '.(a:flags =~# 'r' ? 'N' : 'n')
endfunction

" Search for line under cursor
nnoremap <silent> <leader>n :<c-u>call DoSearch('\V\^'.escape(getline('.'), '\').'\$', '')<cr>
nnoremap <silent> <leader>N :<c-u>call DoSearch('\V\^'.escape(getline('.'), '\').'\$', 'r')<cr>
" Search for visual selection
xnoremap <silent> <leader>n :<c-u>call DoSearch(GetVisualSelectionAsRegex(), '')<cr>
xnoremap <silent> <leader>N :<c-u>call DoSearch(GetVisualSelectionAsRegex(), 'r')<cr>

"== Whitespace ===============================================================

" By default, indent with 4 spaces, and don't use softtabstop
set tabstop=4 shiftwidth=4 expandtab
" But prefer other indents for some specific file types
autocmd vimrc FileType bitbake,gitconfig,cs,javascript setlocal noexpandtab
autocmd vimrc FileType ruby setlocal tabstop=2 shiftwidth=2

set listchars=nbsp:¬,tab:>-,trail:·,eol:$

" Toggle list mode
function! ToggleListMode()
  if !&list
    let whitespace_settings =
          \ 'filetype=' . &ft .
          \ ' tabstop=' . &ts .
          \ ' softtabstop=' . &sts .
          \ ' shiftwidth=' . &sw .
          \ (&et ? ' ' : ' no') . 'expandtab'
    echo whitespace_settings
  else
    echo
  endif
  set list!
endfunction

" Toggle list mode and look at whitespace settings
nnoremap <silent> <leader>s :call ToggleListMode()<cr>

"== Formatting & refactoring =================================================

" Strip trailing whitespace
nnoremap <silent> <leader>S :%s/\s\+$//e <bar>
      \ call histdel('/', -1) <bar>
      \ call setpos('.', getpos("''"))<cr>

" Replace word under cursor
nnoremap <leader>r "0yiw:%s/\<<c-r>0\>//g<c-f>F/i

function! FormatJson() range
  python << EOF
import vim, json
firstline = int(vim.eval("a:firstline"))
lastline = int(vim.eval("a:lastline"))
buf_range = vim.current.buffer.range(firstline, lastline)
obj = json.loads("".join(buf_range))
formatted = json.dumps(obj, indent=4)
buf_range[:] = formatted.split("\n")
EOF
endfunction

" Decrease mediawiki header importance (e.g. = -> ==, == -> ===)
nnoremap <leader>w :%s/^\(=\+\)\s*\(.\{-}\)\s*\(=\+\)\s*/\1= \2 \3=/e<cr>
" Remap lines of tab-delimited fields like like '183E002Z	97' into firmware
" numbers like 'F183E002Z-007'
"nnoremap <leader>x :%s/\(.*\)\t\(\d\+\)/\=printf("F%s-%03i",submatch(1),submatch(2)-89)/<cr>

"== Auto-completion ==========================================================

" <c-x> <c-k> dictionary completion
set dictionary=/usr/share/dict/words

function! TabCompletion(...)
  let col = col('.') - 1
  if !col || getline('.')[col-1] !~ '\k'
    return "\<tab>"
  elseif a:0 > 0 && a:1 == 'prev'
    return "\<c-p>"
  else
    return "\<c-n>"
  endif
endfunction

" Tab / shift-tab shortcuts for i_^x^n and i_^x^p
inoremap <tab> <c-r>=TabCompletion('next')<cr>
inoremap <s-tab> <c-r>=TabCompletion('prev')<cr>

"== Navigation & orientation =================================================

" Allow unsaved background buffers
set hidden
" When splitting, place new window below
set splitbelow
" When vsplitting, place new window to the right
set splitright
" Maintain more context around cursor when scrolling
set scrolloff=3

" Jump to the last known cursor position when opening a file, unless the
" position is invalid, or we're inside an event handler (happens when dropping
" a file on gvim), or when jumping to the first line, or when opening
" gitcommit or gitrebase buffers.
function! s:JumpToLastKnownCursorPosition()
  if line("'\"") <= 1 | return | endif
  if line("'\"") > line("$") | return | endif
  " Ignore git commit messages and git rebase scripts
  if expand("%") =~# '\(^\|/\)\.git/' | return | endif
  execute "normal! g`\"" |
endfunction

autocmd vimrc BufReadPost * call s:JumpToLastKnownCursorPosition()

" Show hidden buffers
nnoremap <leader>l :execute (exists(':CtrlP') ? 'CtrlPBuffer' : 'ls')<cr>

" Open quickfix window on Q
nnoremap <silent> Q :<c-u>copen<cr>
xnoremap <silent> Q :<c-u>copen<cr>

function! s:ViewportMappings()
  let [ystep, xstep] = [5, 10]
  " Move viewport
  execute 'nnoremap <left> '.xstep.'zh'
  execute 'nnoremap <right> '.xstep.'zl'
  execute 'nnoremap <up> '.ystep.'<c-y>'
  execute 'nnoremap <down> '.ystep.'<c-e>'
  " Move viewport a bit faster
  execute 'nnoremap <s-left> '.xstep*3.'zh'
  execute 'nnoremap <s-right> '.xstep*3.'zl'
  execute 'nnoremap <s-up> '.ystep*3.'<c-y>'
  execute 'nnoremap <s-down> '.ystep*3.'<c-e>'
endfunction

function! s:FoldMappings()
  " Navigate to next/previous fold
  nnoremap <up> zk
  nnoremap <down> zj
  " Open/close fold under cursor
  nnoremap <left> zc
  nnoremap <s-left> zC
  nnoremap <right> zo
  nnoremap <s-right> zO
  " Create folds
  xnoremap <left> zf
endfunction

function! s:BufferMappings()
  " Cycle buffers
  nnoremap <silent> <left> :bprev<cr>
  nnoremap <silent> <right> :bnext<cr>
  nnoremap <silent> <up> :bprev<cr>
  nnoremap <silent> <down> :bnext<cr>
endfunction

function! s:WindowMappings()
  " Switch focus to adjacent window
  nnoremap <left> <c-w>h
  nnoremap <right> <c-w>l
  nnoremap <up> <c-w>k
  nnoremap <down> <c-w>j
  " Move active window
  nnoremap <s-left> <c-w>H
  nnoremap <s-right> <c-w>L
  nnoremap <s-up> <c-w>K
  nnoremap <s-down> <c-w>J
  " Discard unfocused windows
  " (disabled because it interferes with quickfix usage)
  "nnoremap <silent> <cr> :only<cr>
endfunction

function! s:TabPageMappings()
  " Cycle tabs
  nnoremap <silent> <left> :tabprev<cr>
  nnoremap <silent> <right> :tabnext<cr>
  " Move active tab relative to other tabs
  nnoremap <silent> <s-left> :tabmove -1<cr>
  nnoremap <silent> <s-right> :tabmove +1<cr>
endfunction

" Orig  +Delta = Result:
" ''        +1 = 'HEAD~1'
" 'HEAD'    +1 = 'HEAD~1'
" 'HEAD~10' +1 = 'HEAD~11'
" 'HEAD^2'  +1 = 'HEAD^2~1'
" 'HEAD~1'  -1 = ''
function! IncSignifyDiffScope(delta)
  let options = g:signify_diffoptions
  let base = get(options, 'git', 'HEAD')
  let parts = split(base, '\~\ze\d\+$')
  let offset = str2nr(get(parts, 1)) + a:delta
  let options.git = offset > 0 ? get(parts, 0, 'HEAD') . '~' . offset : ''
  call sy#start()
  echo 'let g:signify_diffoptions.git =' options.git
endfunction

function! s:DiffMappings()
  nnoremap <silent> <up> :call IncSignifyDiffScope(-1)<cr>
  nnoremap <silent> <down> :call IncSignifyDiffScope(+1)<cr>
endfunction

" Enable various navigation shortcuts with <leader>k.
" Mnemonic: 'k' = 'keys', since most of the mappings are arrow-key oriented.
nnoremap <silent> <leader>kv :call <sid>ViewportMappings()<cr>
nnoremap <silent> <leader>kf :call <sid>FoldMappings()<cr>
nnoremap <silent> <leader>kb :call <sid>BufferMappings()<cr>
nnoremap <silent> <leader>kw :call <sid>WindowMappings()<cr>
nnoremap <silent> <leader>kt :call <sid>TabPageMappings()<cr>
nnoremap <silent> <leader>kd :call <sid>DiffMappings()<cr>

"== Vim experimentation ======================================================

" Create a new vim buffer for on-the-fly experiments.
" Inspired by Gary Bernhardt.
function! s:VimScratchBuffer(path) abort
  execute 'vsplit '.a:path
  set bufhidden=wipe
endfunction

nnoremap <silent> <leader>e :call <sid>VimScratchBuffer(tempname().'.vim')<cr>
nnoremap <silent> <leader>E :call <sid>VimScratchBuffer($MYVIMRC)<cr>

"== File types ===============================================================

" Detect file type and enable language-specific settings and indentation
filetype plugin indent on

" Detect InstallShield scripts
autocmd vimrc BufNewFile,BufRead *.rul set filetype=ishd

function! s:VimFileType()
  setlocal tabstop=2 shiftwidth=2
  " Show a line at 79
  setlocal colorcolumn=79
  " Open vim help for word under cursor
  setlocal keywordprg=:help
  " Save and source current vim buffer
  nnoremap <silent> <buffer> <leader>x
        \ :silent update <bar> source % <bar> execute 'setf '.&ft<cr>
endfunction

autocmd vimrc FileType vim call s:VimFileType()

function! s:JavascriptFileType()
  setlocal makeprg=jshint
  setlocal errorformat=%f:\ line\ %l\\,\ col\ %c\\,\ %m,%-G%.%#
  if executable(&makeprg)
    " Find the nearest .jshintrc
    let config_path = findfile(".jshintrc", expand("%:p:h").";")
    if config_path != ''
      let &l:makeprg .= printf(" --config %s", config_path)
    endif
    command! -buffer Make
          \ silent make % | silent redraw! | silent botright cwindow
  else
    execute "command! -buffer Make echoerr 'Bad makeprg: ".&makeprg."'"
  endif
  nnoremap <buffer> <F7> :<c-u>Make<cr>
endfunction

autocmd vimrc FileType javascript call s:JavascriptFileType()

" JSON
autocmd vimrc BufNewFile,BufRead .jshintrc setf json

" https://github.com/elzr/vim-json
let g:vim_json_syntax_conceal = 0

" Reformats rst table
function! s:FormatRstTable()
  let saved_cursor = getcurpos()
  " Trim all row separators to be super tiny (+-+-+...)
  '{,'}g/^+-/s/-\+/-/g
  '{,'}g/^+=/s/=\+/=/g
  " Normalize columns
  Tabularize /\(+\||\)/
  " Fill in the gaps in row separators
  '{,'}g/^+ -/s/ /-/g
  '{,'}g/^+ =/s/ /=/g
  call setpos('.', saved_cursor)
endfunction

function! s:WrapRstTableCellLine()
  " Delete remainder of line
  execute "normal d/\\ze\\s\\+|$\<cr>"
  let saved_cursor = getcurpos()
  " Clone current line
  copy .
  " Clean it out and fill it with the deleted text
  s/[^|]/ /g
  call setpos('.', saved_cursor)
  execute "normal jT|p"
endfunction

function! s:RstFileType()
  nnoremap <silent> <leader>ft :silent call <sid>FormatRstTable()<cr>
  nnoremap <silent> <leader>fw :silent call <sid>WrapRstTableCellLine()<cr>
endfunction

autocmd vimrc FileType rst call s:RstFileType()

"== Colors ===================================================================

" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
if &t_Co > 2 || has("gui_running")
  syntax on
endif

function! SetColorScheme(...)
  for name in a:000
    try
      execute 'colorscheme ' . name
      break
    catch /^Vim\%((\a\+)\)\=:E185/
    endtry
  endfor
endfunction

if has("gui_running")
  call SetColorScheme("desert256", "desert")
elseif &t_Co == 256
  call SetColorScheme("busybee", "desert256", "desert")
else
  call SetColorScheme("desert")
endif

" Change the paren matching color to stand out in the chosen color scheme.
" This must be executed after vim starts, because otherwise the matchparen
" plugin overwrites the specified value with its own default on load.
autocmd vimrc VimEnter * highlight MatchParen ctermbg=magenta

"== Gvim =====================================================================

if has("gui_running")
  set lines=40 columns=130 " Default height / width
  set guioptions-=m  " Disable menu bar
  set guioptions-=T  " Disable toolbar
  set guioptions-=r  " Disable right-hand scroll bar
  set mouse-=a       " Disable mouse
  set shell=bash     " Avoid zsh on dumb terminals
endif

" OS-specific tweaks
if has("gui_gtk2")
  set guifont=Inconsolata\ 12
elseif has("gui_macvim")
  set guifont=Menlo\ Regular:h14
elseif has("gui_win32")
  set guifont=Consolas:h10:cANSI
  " Disable tearoff menu entries
  set guioptions-=t
endif

"== Misc =====================================================================

" Open a file from the current buffer's dir
"nnoremap <leader>e :e <C-R>=expand("%:p:h") . "/" <cr>

" Change dir to the directory of the current buffer
nnoremap <leader>c :cd %:p:h \| :pwd<cr>

" Generic test runner mapping
nnoremap <leader>t :nnoremap <lt>leader>t :w \\| !./%<lt>cr><c-f>4h

function! s:LoadAdditionalVimScript(name, path) abort
  " Look for an additional script between a:path and file system root
  let extra_script = resolve(findfile(a:name, escape(a:path, ' ').';'))
  if extra_script == '' | return | endif

  " Avoid re-loading scripts that have already been loaded
  redir => scriptnames_output | scriptnames | redir END
  for line in split(scriptnames_output, '\r\?\n')
    let script_path = substitute(line, '\v^\s*\d+:\s+', '', '')
    if resolve(fnamemodify(script_path, ':p')) == extra_script | return | endif
  endfor

  exec 'source '.escape(extra_script, ' ')
endfunction
silent call s:LoadAdditionalVimScript('.vimrclocal', $PWD)

" Define all remaining <leader>[a-zA-Z] mappings
for ch in split('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', '\zs')
  if mapcheck('<leader>' . ch, "n") == ""
    let cmd = 'nnoremap <leader>%s :<c-u>echoerr "Unassigned mapping"<cr>'
    execute printf(cmd, ch)
  endif
endfor
